import * as grpc from '@grpc/grpc-js';
import { google } from './proto/google/protobuf/struct';
import { tsdb } from './proto/api/tsdb/tsdb';
import { credentials } from '@grpc/grpc-js';

// Type definition for a data point to be put
export interface PutDataPoint {
  metric: string;
  tags?: Record<string, string>;
  fields: Record<string, any>;
  ts?: Date;
}

// Type definitions for client options
export interface NexusClientOptions {
  host?: string;
  port?: number;
  useTls?: boolean;
  authToken?: string;
  // Add other options like ca_cert_path if needed
}

// Type definition for a query
export interface QueryParams {
  metric: string;
  startTime?: Date;
  endTime?: Date;
  tags?: Record<string, string>;
  aggregations?: {
    func: tsdb.AggregationSpec.AggregationFunc;
    field: string;
  }[];
  downsampleInterval?: string;
  limit?: number;
}

/**
 * NexusBaseClient provides a high-level API for interacting with the NexusBase TSDB.
 */
export class NexusBaseClient {
  private client: tsdb.TSDBServiceClient;

  constructor(options: NexusClientOptions = {}) {
    const {
      host = 'localhost',
      port = 50051,
      useTls = false,
      authToken,
    } = options;

    const address = `${host}:${port}`;
    let creds: grpc.ChannelCredentials;

    if (useTls) {
      // For production, load CA certs properly.
      // This is a basic TLS setup.
      creds = credentials.createSsl();
    } else {
      creds = credentials.createInsecure();
    }

    let callCreds: grpc.CallCredentials | undefined;
    if (authToken) {
      const metadata = new grpc.Metadata();
      metadata.set('authorization', `Bearer ${authToken}`); // Assuming Bearer token auth
      callCreds = grpc.credentials.createFromMetadataGenerator((_, callback) => {
        callback(null, metadata);
      });
    }

    if (callCreds) {
      creds = grpc.credentials.combineChannelCredentials(creds, callCreds);
    }

    this.client = new tsdb.TSDBServiceClient(address, creds);
  }

  /**
   * Puts a single data point into the database.
   * @param point The data point to insert.
   * @returns A promise that resolves when the operation is complete.
   */
  public put(point: PutDataPoint): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = new tsdb.PutRequest();
      request.metric = point.metric;

      if (point.tags) {
        // The 'tags' property on the generated type is a Map.
        request.tags = new Map(Object.entries(point.tags));
      }

      // The 'fields' property is a Struct.
      // The type generated by protoc-gen-ts for Struct is nominally incompatible with the one from the google-protobuf library.
      // We must construct the Struct instance from the generated code, not from the 'google-protobuf' library,
      // to ensure it has the correct prototype chain and methods (like .serialize()).
      const fieldsStruct = new google.protobuf.Struct();
      fieldsStruct.fields = new Map<string, google.protobuf.Value>();

      for (const [key, value] of Object.entries(point.fields)) {
        const pbValue = new google.protobuf.Value();
        switch (typeof value) {
          case 'string':
            pbValue.string_value = value;
            break;
          case 'number':
            pbValue.number_value = value;
            break;
          case 'boolean':
            pbValue.bool_value = value;
            break;
          case 'object':
            // This handles `null`. A more complex implementation would handle nested structs/lists.
            if (value === null) {
              pbValue.null_value = google.protobuf.NullValue.NULL_VALUE;
            }
            break;
          default:
            // For `undefined` or other types, treat as null.
            pbValue.null_value = google.protobuf.NullValue.NULL_VALUE;
            break;
        }
        fieldsStruct.fields.set(key, pbValue);
      }
      request.fields = fieldsStruct;

      // Timestamp is in nanoseconds. JS Date.getTime() is milliseconds.
      const timestamp = point.ts ? point.ts.getTime() * 1_000_000 : Date.now() * 1_000_000;
      request.timestamp = timestamp;

      this.client.Put(request, (err: grpc.ServiceError | null, _response: tsdb.PutResponse | undefined) => {
        if (err) {
          return reject(err);
        }
        resolve();
      });
    });
  }

  /**
   * Puts a batch of data points into the database.
   * @param points An array of data points to insert.
   * @returns A promise that resolves when the operation is complete.
   */
  public putBatch(points: PutDataPoint[]): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!points || points.length === 0) {
        return resolve();
      }

      const putRequests = points.map(point => {
        const request = new tsdb.PutRequest();
        request.metric = point.metric;

        if (point.tags) {
          request.tags = new Map(Object.entries(point.tags));
        }

        const fieldsStruct = new google.protobuf.Struct();
        fieldsStruct.fields = new Map<string, google.protobuf.Value>();

        for (const [key, value] of Object.entries(point.fields)) {
          const pbValue = new google.protobuf.Value();
          switch (typeof value) {
            case 'string':
              pbValue.string_value = value;
              break;
            case 'number':
              pbValue.number_value = value;
              break;
            case 'boolean':
              pbValue.bool_value = value;
              break;
            case 'object':
              if (value === null) {
                pbValue.null_value = google.protobuf.NullValue.NULL_VALUE;
              }
              break;
            default:
              pbValue.null_value = google.protobuf.NullValue.NULL_VALUE;
              break;
          }
          fieldsStruct.fields.set(key, pbValue);
        }
        request.fields = fieldsStruct;

        const timestamp = point.ts ? point.ts.getTime() * 1_000_000 : Date.now() * 1_000_000;
        request.timestamp = timestamp;
        return request;
      });

      const batchRequest = new tsdb.PutBatchRequest({ points: putRequests });
      this.client.PutBatch(batchRequest, (err: grpc.ServiceError | null, _response: tsdb.PutBatchResponse | undefined) => {
        if (err) {
          return reject(err);
        }
        resolve();
      });
    });
  }

  /**
   * Queries the database for time series data.
   * @param params The query parameters.
   * @returns An async generator that yields query results.
   */
  public async *query(params: QueryParams): AsyncGenerator<ReturnType<tsdb.QueryResult['toObject']>, void, unknown> {
    const request = new tsdb.QueryRequest();
    request.metric = params.metric;
    if (params.startTime) {
      request.start_time = params.startTime.getTime() * 1_000_000;
    }
    if (params.endTime) {
      request.end_time = params.endTime.getTime() * 1_000_000;
    }

    if (params.tags) {
      request.tags = new Map(Object.entries(params.tags));
    }

    if (params.aggregations) {
      request.aggregation_specs = params.aggregations.map((agg) => {
        const spec = new tsdb.AggregationSpec();
        spec.function = agg.func;
        spec.field = agg.field;
        return spec;
      });
    }

    if (params.downsampleInterval) {
      request.downsample_interval = params.downsampleInterval;
    }

    if (params.limit) {
      request.limit = params.limit;
    }

    const stream = this.client.Query(request);

    let count = 0;
    for await (const result of stream) {
      if (params.limit && count >= params.limit) {
        break;
      }
      yield result.toObject();
      count++;
    }
  }

  /**
   * Closes the gRPC client connection.
   */
  public close(): void {
    this.client.close();
  }
}