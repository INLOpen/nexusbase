<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexusBase - Go Runtime Monitor (memstats)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f4f7f6; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h1 { color: #2c3e50; text-align: center; border-bottom: 2px solid #e0e0e0; padding-bottom: 15px; margin-top: 0; }
        h2 { color: #34495e; margin-top: 40px; border-bottom: 1px solid #eee; padding-bottom: 10px;}
        #status { text-align: center; padding: 10px; margin-bottom: 20px; border-radius: 5px; font-weight: bold; }
        .status-ok { background-color: #e8f5e9; color: #2e7d32; }
        .status-error { background-color: #ffebee; color: #c62828; }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
        }
        .stat-card .title {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        .stat-card .value {
            font-size: 22px;
            font-weight: 600;
            color: #2c3e50;
        }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; font-weight: 600; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        td.numeric { text-align: right; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Go Runtime Monitor (memstats)</h1>
        <div id="status">Connecting...</div>

        <h2>Memory Overview</h2>
        <div class="stats-grid">
            <div class="stat-card" id="alloc-card"><div class="title">Heap Allocated</div><div class="value">-</div></div>
            <div class="stat-card" id="total-alloc-card"><div class="title">Total Allocated</div><div class="value">-</div></div>
            <div class="stat-card" id="sys-card"><div class="title">Total from OS</div><div class="value">-</div></div>
            <div class="stat-card" id="lookups-card"><div class="title">Pointer Lookups</div><div class="value">-</div></div>
            <div class="stat-card" id="mallocs-card"><div class="title">Mallocs</div><div class="value">-</div></div>
            <div class="stat-card" id="frees-card"><div class="title">Frees</div><div class="value">-</div></div>
        </div>

        <h2>Live Graphs</h2>
        <div class="charts-grid">
            <div class="chart-container">
                <canvas id="heapMemoryChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="objectCountChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="gcPauseChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="gcCpuFractionChart"></canvas>
            </div>
        </div>

        <h2>Garbage Collector Details</h2>
        <div class="stats-grid">
            <div class="stat-card" id="next-gc-card"><div class="title">Next GC at</div><div class="value">-</div></div>
            <div class="stat-card" id="last-gc-card"><div class="title">Last GC</div><div class="value">-</div></div>
            <div class="stat-card" id="num-gc-card"><div class="title">Total GC Runs</div><div class="value">-</div></div>
            <div class="stat-card" id="pause-total-card"><div class="title">Total Pause</div><div class="value">-</div></div>
        </div>

        <h2>GC Pause Histogram (Last 256 cycles)</h2>
        <div class="chart-container" style="height: 350px;">
            <canvas id="gcPauseHistogram"></canvas>
        </div>

        <h2>Memory by Size Class</h2>
        <div id="by-size-table-container">
            <p>Loading...</p>
        </div>
    </div>

    <script>
        const MAX_DATA_POINTS = 60; // Keep last 60 points (2 minutes at 2s interval)

        // Data stores for charts
        const chartData = {
            labels: [],
            heapAlloc: [],
            heapSys: [],
            heapIdle: [],
            heapInuse: [],
            heapObjects: [],
            mallocsDelta: [],
            freesDelta: [],
            gcPauseNs: [],
            gcCpuFraction: [],
        };

        let lastMallocs = 0;
        let lastFrees = 0;

        // Helper to create a chart
        function createChart(ctx, label, datasets, type = 'line') {
            return new Chart(ctx, {
                type: type,
                data: { labels: chartData.labels, datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { type: 'time', time: { unit: 'second', tooltipFormat: 'HH:mm:ss' }, ticks: { maxTicksLimit: 10 } },
                        y: { beginAtZero: true }
                    },
                    plugins: { legend: { position: 'top' }, title: { display: true, text: label } },
                    elements: { point: { radius: 1 }, line: { tension: 0.1 } }
                }
            });
        }

        // Helper to format bytes
        function formatBytes(value) {
            if (value === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(value) / Math.log(k));
            return parseFloat((value / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize charts
        const heapMemoryChart = createChart(document.getElementById('heapMemoryChart').getContext('2d'), 'Heap Memory Usage', [
            { label: 'In Use (HeapAlloc)', data: chartData.heapAlloc, borderColor: 'rgb(54, 162, 235)', backgroundColor: 'rgba(54, 162, 235, 0.5)' },
            { label: 'Reserved (HeapSys)', data: chartData.heapSys, borderColor: 'rgb(255, 99, 132)', backgroundColor: 'rgba(255, 99, 132, 0.5)' },
            { label: 'Idle (HeapIdle)', data: chartData.heapIdle, borderColor: 'rgb(75, 192, 192)', backgroundColor: 'rgba(75, 192, 192, 0.5)' }
        ]);
        heapMemoryChart.options.scales.y.ticks.callback = formatBytes;

        const objectCountChart = createChart(document.getElementById('objectCountChart').getContext('2d'), 'Object Allocation Rate', [
            { label: 'Mallocs/interval', data: chartData.mallocsDelta, borderColor: 'rgb(255, 159, 64)', backgroundColor: 'rgba(255, 159, 64, 0.5)' },
            { label: 'Frees/interval', data: chartData.freesDelta, borderColor: 'rgb(153, 102, 255)', backgroundColor: 'rgba(153, 102, 255, 0.5)' }
        ]);

        const gcPauseChart = createChart(document.getElementById('gcPauseChart').getContext('2d'), 'GC Pause per Interval (ms)', [
            { label: 'GC Pause', data: chartData.gcPauseNs, borderColor: 'rgb(231, 76, 60)', backgroundColor: 'rgba(231, 76, 60, 0.5)', type: 'bar' }
        ]);
        gcPauseChart.options.scales.y.ticks.callback = (value) => `${(value / 1e6).toFixed(3)} ms`;

        const gcCpuFractionChart = createChart(document.getElementById('gcCpuFractionChart').getContext('2d'), 'GC CPU Fraction (%)', [
            { label: 'GC CPU %', data: chartData.gcCpuFraction, borderColor: 'rgb(241, 196, 15)', backgroundColor: 'rgba(241, 196, 15, 0.5)' }
        ]);
        gcCpuFractionChart.options.scales.y.ticks.callback = (value) => `${(value * 100).toFixed(4)} %`;

        let gcPauseHistogramChart = null;
        let lastTotalGCPauseNs = 0;

        async function fetchMetrics() {
            try {
                const response = await fetch('/metrics');
                if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
                const data = await response.json();
                updateUI(data.memstats);
                document.getElementById('status').textContent = 'Connected. Last updated: ' + new Date().toLocaleTimeString();
                document.getElementById('status').className = 'status-ok';
            } catch (error) {
                console.error('Error fetching metrics:', error);
                document.getElementById('status').textContent = `Error: ${error.message}`;
                document.getElementById('status').className = 'status-error';
            }
        }

        function updateUI(memstats) {
            if (!memstats) return;

            // --- Update Stat Cards ---
            document.querySelector('#alloc-card .value').textContent = formatBytes(memstats.Alloc);
            document.querySelector('#total-alloc-card .value').textContent = formatBytes(memstats.TotalAlloc);
            document.querySelector('#sys-card .value').textContent = formatBytes(memstats.Sys);
            document.querySelector('#lookups-card .value').textContent = memstats.Lookups.toLocaleString();
            document.querySelector('#mallocs-card .value').textContent = memstats.Mallocs.toLocaleString();
            document.querySelector('#frees-card .value').textContent = memstats.Frees.toLocaleString();
            document.querySelector('#next-gc-card .value').textContent = formatBytes(memstats.NextGC);
            document.querySelector('#last-gc-card .value').textContent = memstats.LastGC > 0 ? new Date(memstats.LastGC / 1e6).toLocaleTimeString() : 'N/A';
            document.querySelector('#num-gc-card .value').textContent = memstats.NumGC.toLocaleString();
            document.querySelector('#pause-total-card .value').textContent = `${(memstats.PauseTotalNs / 1e9).toFixed(2)} s`;

            // --- Update Chart Data ---
            const now = new Date();
            chartData.labels.push(now);
            chartData.heapAlloc.push(memstats.HeapAlloc);
            chartData.heapSys.push(memstats.HeapSys);
            chartData.heapIdle.push(memstats.HeapIdle);
            chartData.heapInuse.push(memstats.HeapInuse);
            chartData.heapObjects.push(memstats.HeapObjects);
            chartData.gcCpuFraction.push(memstats.GCCPUFraction);

            // Calculate deltas for mallocs/frees
            chartData.mallocsDelta.push(lastMallocs > 0 ? memstats.Mallocs - lastMallocs : 0);
            chartData.freesDelta.push(lastFrees > 0 ? memstats.Frees - lastFrees : 0);
            lastMallocs = memstats.Mallocs;
            lastFrees = memstats.Frees;

            // Calculate GC pause for this interval
            const currentTotalGCPauseNs = memstats.PauseTotalNs || 0;
            let gcPauseThisInterval = 0;
            if (lastTotalGCPauseNs > 0 && currentTotalGCPauseNs > lastTotalGCPauseNs) {
                gcPauseThisInterval = currentTotalGCPauseNs - lastTotalGCPauseNs;
            }
            chartData.gcPauseNs.push(gcPauseThisInterval);
            lastTotalGCPauseNs = currentTotalGCPauseNs;

            // Limit data points
            if (chartData.labels.length > MAX_DATA_POINTS) {
                Object.keys(chartData).forEach(key => {
                    if (Array.isArray(chartData[key])) chartData[key].shift();
                });
            }

            // --- Update Charts ---
            heapMemoryChart.update();
            objectCountChart.update();
            gcPauseChart.update();
            gcCpuFractionChart.update();

            // --- Update Tables and Histograms ---
            updatePauseHistogram(memstats.PauseNs);
            updateBySizeTable(memstats.BySize);
        }

        function updatePauseHistogram(pauseNs) {
            if (!pauseNs || !Array.isArray(pauseNs)) return;

            const validPauses = pauseNs.filter(ns => ns > 0).map(ns => ns / 1e6); // convert to ms
            if (validPauses.length === 0) return;

            const maxPause = Math.max(...validPauses);
            const binCount = 20;
            const binSize = maxPause / binCount;

            const bins = new Array(binCount).fill(0);
            const labels = new Array(binCount);

            for (let i = 0; i < binCount; i++) {
                labels[i] = `${(i * binSize).toFixed(3)} ms`;
            }

            validPauses.forEach(pause => {
                let binIndex = Math.floor(pause / binSize);
                if (binIndex >= binCount) binIndex = binCount - 1;
                bins[binIndex]++;
            });

            const ctx = document.getElementById('gcPauseHistogram').getContext('2d');
            if (gcPauseHistogramChart) {
                gcPauseHistogramChart.data.labels = labels;
                gcPauseHistogramChart.data.datasets[0].data = bins;
                gcPauseHistogramChart.update();
            } else {
                gcPauseHistogramChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Number of Pauses',
                            data: bins,
                            backgroundColor: 'rgba(231, 76, 60, 0.7)',
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true, ticks: { precision: 0 } } }
                    }
                });
            }
        }

        function updateBySizeTable(bySize) {
            const container = document.getElementById('by-size-table-container');
            if (!bySize || !Array.isArray(bySize)) {
                container.innerHTML = '<p>BySize stats not available.</p>';
                return;
            }

            let tableHTML = '<table><thead><tr><th>Size Class (Bytes)</th><th>Mallocs</th><th>Frees</th></tr></thead><tbody>';
            bySize.forEach(sizeClass => {
                if (sizeClass.Mallocs > 0 || sizeClass.Frees > 0) {
                    tableHTML += `
                        <tr>
                            <td class="numeric">&lt;= ${sizeClass.Size}</td>
                            <td class="numeric">${sizeClass.Mallocs.toLocaleString()}</td>
                            <td class="numeric">${sizeClass.Frees.toLocaleString()}</td>
                        </tr>
                    `;
                }
            });
            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;
        }

        // Initial fetch and setup timer
        fetchMetrics();
        setInterval(fetchMetrics, 2000);
    </script>
</body>
</html>