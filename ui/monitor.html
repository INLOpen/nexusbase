<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexusBase Metrics Monitor</title>
    <!-- 1. Add Chart.js and date adapter from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f4f7f6; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h1 { color: #2c3e50; text-align: center; border-bottom: 2px solid #e0e0e0; padding-bottom: 15px; margin-top: 0; }
        h2 { color: #34495e; margin-top: 40px; border-bottom: 1px solid #eee; padding-bottom: 10px;}
        #status { text-align: center; padding: 10px; margin-bottom: 20px; border-radius: 5px; font-weight: bold; }
        .controls {
            text-align: right;
            margin-bottom: 15px;
        }
        .controls label {
            margin-right: 8px;
            font-weight: 500;
        }
        .controls button {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            margin-right: 15px;
        }
        .controls select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .status-ok { background-color: #e8f5e9; color: #2e7d32; }
        .status-error { background-color: #ffebee; color: #c62828; }
        .charts-grid {
            display: grid;
            /* Let's go with 3 columns for a denser layout */
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; color: #333; font-weight: 600; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        tr:hover { background-color: #f1f1f1; }
        .metric-key { font-family: "Courier New", Courier, monospace; font-weight: bold; color: #34495e; }
        .metric-value { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; color: #27ae60; }
        pre { white-space: pre-wrap; margin: 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>NexusBase Metrics Monitor</h1>
        <div class="controls">
            <button id="resetZoomBtn">Reset Zoom</button>
            <label for="refreshInterval">Refresh Interval:</label>
            <select id="refreshInterval">
                <option value="2000" selected>2 seconds</option>
                <option value="5000">5 seconds</option>
                <option value="10000">10 seconds</option>
                <option value="0">Paused</option>
            </select>
        </div>

        <div id="status">Connecting...</div>

        <!-- 2. Add canvas elements for charts -->
        <h2>Live Graphs</h2>
        <div class="charts-grid">
            <div class="chart-container">
                <canvas id="memtableChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="ingestionRateChart"></canvas>
            </div>
            <!-- Add new canvases for system usage -->
            <div class="chart-container">
                <canvas id="cpuUsageChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="memoryUsageChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="goHeapAllocChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="diskUsageChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="cacheHitRateChart"></canvas>
            </div>
             <div class="chart-container">
                <canvas id="l0FilesChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="lsmTreeChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="qpsChart"></canvas>
            </div>
        </div>

        <h2>All Metrics</h2>
        <table id="metrics-table">
            <thead>
                <tr>
                    <th>Metric Name</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody id="metrics-body">
            </tbody>
        </table>
    </div>

    <script>
        const metricsBody = document.getElementById('metrics-body');
        const statusDiv = document.getElementById('status');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const refreshIntervalSelect = document.getElementById('refreshInterval');
        let refreshTimerId = null;
        const MAX_DATA_POINTS = 30; // Keep last 30 points for graphs

        // Data stores for charts
        const chartData = {
            labels: [],
            memtableSize: [],
            immutableCount: [],
            goHeapAlloc: [],
            ingestionRate: [],
            cacheHitRate: [],
            cpuUsage: [],
            memoryUsage: [],
            diskUsage: [],
            l0FileCount: [],
            qps: [], // Queries Per Second
            lsmLevelSizes: [] // Array of arrays for each level's size history
        };

        // Helper to create a chart
        function createChart(ctx, label, datasets) {
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'second',
                                tooltipFormat: 'HH:mm:ss',
                                displayFormats: {
                                    second: 'HH:mm:ss'
                                }
                            },
                            ticks: {
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: label
                        },
                        // 3. Add zoom and pan plugin configuration
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x', // Allow panning only on the x-axis (time)
                            },
                            zoom: {
                                wheel: {
                                    enabled: true, // Enable zooming with the mouse wheel
                                },
                                pinch: {
                                    enabled: true // Enable pinch zooming on touch devices
                                },
                                mode: 'x', // Allow zooming only on the x-axis
                            }
                        },
                    },
                    elements: {
                        point: {
                            radius: 1
                        },
                        line: {
                            tension: 0.1
                        }
                    }
                }
            });
        }

        // Initialize charts
        const memtableChart = createChart(document.getElementById('memtableChart').getContext('2d'), 'Memtable State', [
            {
                label: 'Mutable Memtable Size (Bytes)',
                data: chartData.memtableSize,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.5)',
                yAxisID: 'y',
            },
            {
                label: 'Immutable Memtables Count',
                data: chartData.immutableCount,
                borderColor: 'rgb(255, 99, 132)',
                backgroundColor: 'rgba(255, 99, 132, 0.5)',
                yAxisID: 'y1',
            }
        ]);
        memtableChart.options.scales.y1 = {
            type: 'linear',
            display: true,
            position: 'right',
            grid: {
                drawOnChartArea: false, // only want the grid lines for one axis to show up
            },
            ticks: {
                precision: 0 // Ensure integer ticks for count
            }
        };


        const ingestionRateChart = createChart(document.getElementById('ingestionRateChart').getContext('2d'), 'Ingestion Rate (points/sec)', [
            {
                label: 'Points / Second',
                data: chartData.ingestionRate,
                borderColor: 'rgb(54, 162, 235)',
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
            }
        ]);

        const cacheHitRateChart = createChart(document.getElementById('cacheHitRateChart').getContext('2d'), 'Block Cache Hit Rate (%)', [
            {
                label: 'Hit Rate',
                data: chartData.cacheHitRate,
                borderColor: 'rgb(255, 205, 86)',
                backgroundColor: 'rgba(255, 205, 86, 0.5)',
            }
        ]);
        cacheHitRateChart.options.scales.y.max = 100; // Hit rate is a percentage
        cacheHitRateChart.options.scales.y.min = 0;

        const l0FilesChart = createChart(document.getElementById('l0FilesChart').getContext('2d'), 'Level 0 Files', [
            {
                label: 'L0 File Count',
                data: chartData.l0FileCount,
                borderColor: 'rgb(153, 102, 255)',
                backgroundColor: 'rgba(153, 102, 255, 0.5)',
                stepped: true,
            }
        ]);
        l0FilesChart.options.scales.y.ticks = {
            precision: 0 // Ensure integer ticks for count
        };

        // 3. Initialize the new LSM Tree chart
        const lsmDatasets = [];
        const levelColors = [
            'rgba(255, 99, 132, 0.7)', 'rgba(255, 159, 64, 0.7)', 'rgba(255, 205, 86, 0.7)',
            'rgba(75, 192, 192, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(201, 203, 207, 0.7)'
        ];
        const MAX_LEVELS = 7; // As per default config
        for (let i = 0; i < MAX_LEVELS; i++) {
            chartData.lsmLevelSizes.push([]); // Initialize data array for each level
            lsmDatasets.push({
                label: `Level ${i}`,
                data: chartData.lsmLevelSizes[i],
                borderColor: levelColors[i],
                backgroundColor: levelColors[i],
                fill: true,
            });
        }

        const lsmTreeChart = createChart(document.getElementById('lsmTreeChart').getContext('2d'), 'LSM Tree Level Sizes', lsmDatasets);
        lsmTreeChart.options.scales.y = {
            stacked: true,
            beginAtZero: true,
            ticks: {
                // Callback to format bytes into KB, MB, GB
                callback: function(value, index, values) {
                    if (value === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(value) / Math.log(k));
                    return parseFloat((value / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                }
            }
        };
        lsmTreeChart.options.plugins.tooltip = {
            mode: 'index',
            intersect: false,
        };
        lsmTreeChart.options.plugins.legend.position = 'right';

        const qpsChart = createChart(document.getElementById('qpsChart').getContext('2d'), 'Query Rate (QPS)', [
            {
                label: 'Queries / Second',
                data: chartData.qps,
                borderColor: 'rgb(46, 204, 113)',
                backgroundColor: 'rgba(46, 204, 113, 0.5)',
            }
        ]);

        const goHeapAllocChart = createChart(document.getElementById('goHeapAllocChart').getContext('2d'), 'Go Heap Allocation', [
            {
                label: 'Heap Alloc',
                data: chartData.goHeapAlloc,
                borderColor: 'rgb(153, 102, 255)',
                backgroundColor: 'rgba(153, 102, 255, 0.5)',
            }
        ]);
        // This chart's Y-axis should be formatted as bytes.
        goHeapAllocChart.options.scales.y.ticks.callback = formatBytes;


        // Initialize new system usage charts
        const cpuUsageChart = createChart(document.getElementById('cpuUsageChart').getContext('2d'), 'CPU Usage (%)', [
            {
                label: 'CPU Usage',
                data: chartData.cpuUsage,
                borderColor: 'rgb(255, 159, 64)',
                backgroundColor: 'rgba(255, 159, 64, 0.5)',
            }
        ]);
        cpuUsageChart.options.scales.y.max = 100;
        cpuUsageChart.options.scales.y.min = 0;

        const memoryUsageChart = createChart(document.getElementById('memoryUsageChart').getContext('2d'), 'System Memory Usage (%)', [
            {
                label: 'Memory Usage',
                data: chartData.memoryUsage,
                borderColor: 'rgb(75, 192, 75)',
                backgroundColor: 'rgba(75, 192, 75, 0.5)',
            }
        ]);
        memoryUsageChart.options.scales.y.max = 100;
        memoryUsageChart.options.scales.y.min = 0;

        const diskUsageChart = createChart(document.getElementById('diskUsageChart').getContext('2d'), 'Disk Usage (%)', [
            {
                label: 'Disk Usage',
                data: chartData.diskUsage,
                borderColor: 'rgb(201, 203, 207)',
                backgroundColor: 'rgba(201, 203, 207, 0.5)',
            }
        ]);
        diskUsageChart.options.scales.y.max = 100;
        diskUsageChart.options.scales.y.min = 0;


        async function fetchMetrics() {
            try {
                // Use /api/metrics to avoid conflicts with Prometheus scrapers on /metrics
                const response = await fetch('/metrics');
                if (!response.ok) {
                    throw new Error(`Failed to fetch metrics: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                updateMetricsTable(data);
                updateCharts(data);
                updateStatus('Connected and receiving data. Last updated: ' + new Date().toLocaleTimeString(), 'ok');
            } catch (error) {
                console.error('Error fetching metrics:', error);
                updateStatus(`Error: ${error.message}`, 'error');
            }
        }

        function updateCharts(data) {
            const now = new Date();

            // Add new data
            chartData.labels.push(now);
            chartData.memtableSize.push(data['engine_mutable_memtable_size_bytes'] || 0);
            chartData.immutableCount.push(data['engine_immutable_memtables_count'] || 0);
            chartData.goHeapAlloc.push(data['memstats']['Alloc'] || 0);
            chartData.ingestionRate.push(data['engine_ingestion_rate_points_per_second'] || 0);
            chartData.cpuUsage.push(data['system_cpu_usage_percent'] || 0);
            chartData.memoryUsage.push(data['system_mem_usage_percent'] || 0);
            chartData.diskUsage.push(data['system_disk_usage_percent'] || 0);
            chartData.cacheHitRate.push((data['engine_cache_hit_rate'] || 0) * 100);
            chartData.l0FileCount.push(data['engine_level_0_table_count'] || 0);
            chartData.qps.push(data['engine_queries_per_second'] || 0);
            for (let i = 0; i < MAX_LEVELS; i++) {
                const key = `engine_level_${i}_size_bytes`;
                const size = data[key] || 0;
                chartData.lsmLevelSizes[i].push(size);
            }

            // Limit data points
            if (chartData.labels.length > MAX_DATA_POINTS) {
                chartData.labels.shift();
                chartData.memtableSize.shift();
                chartData.goHeapAlloc.shift();
                chartData.immutableCount.shift();
                chartData.ingestionRate.shift();
                chartData.cacheHitRate.shift();
                chartData.cpuUsage.shift();
                chartData.memoryUsage.shift();
                chartData.diskUsage.shift();
                chartData.l0FileCount.shift();
                chartData.qps.shift();
                for (let i = 0; i < MAX_LEVELS; i++) {
                    chartData.lsmLevelSizes[i].shift();
                }
            }

            // Update charts
            memtableChart.update();
            ingestionRateChart.update();
            cacheHitRateChart.update();
            goHeapAllocChart.update();
            cpuUsageChart.update();
            memoryUsageChart.update();
            diskUsageChart.update();
            l0FilesChart.update();
            qpsChart.update();
            lsmTreeChart.update();
        }

        // Helper function to format bytes
        function formatBytes(value, index, values) {
            if (value === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(value) / Math.log(k));
            return parseFloat((value / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateMetricsTable(data) {
            metricsBody.innerHTML = '';
            const sortedKeys = Object.keys(data).sort();

            for (const key of sortedKeys) {
                const value = data[key];
                const row = document.createElement('tr');

                const keyCell = document.createElement('td');
                keyCell.className = 'metric-key';
                keyCell.textContent = key;

                const valueCell = document.createElement('td');
                valueCell.className = 'metric-value';
                
                if (typeof value === 'object' && value !== null) {
                    const pre = document.createElement('pre');
                    pre.textContent = JSON.stringify(value, null, 2);
                    valueCell.appendChild(pre);
                } else {
                    // Format floats to have a few decimal places
                    if (typeof value === 'number' && !Number.isInteger(value)) {
                         valueCell.textContent = value.toFixed(4);
                    } else {
                        valueCell.textContent = value;
                    }
                }

                row.appendChild(keyCell);
                row.appendChild(valueCell);
                metricsBody.appendChild(row);
            }
        }

        // 4. Add event listener for the reset zoom button
        resetZoomBtn.addEventListener('click', () => {
            memtableChart.resetZoom();
            ingestionRateChart.resetZoom();
            cacheHitRateChart.resetZoom();
            l0FilesChart.resetZoom();
            goHeapAllocChart.resetZoom();
            cpuUsageChart.resetZoom();
            memoryUsageChart.resetZoom();
            diskUsageChart.resetZoom();
            qpsChart.resetZoom();
            lsmTreeChart.resetZoom();
        });

        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = (type === 'ok') ? 'status-ok' : 'status-error';
        }

        function setupRefreshTimer() {
            if (refreshTimerId) {
                clearInterval(refreshTimerId);
            }
            const interval = parseInt(refreshIntervalSelect.value, 10);
            if (interval > 0) {
                refreshTimerId = setInterval(fetchMetrics, interval);
            }
        }

        fetchMetrics();
        setupRefreshTimer();
        refreshIntervalSelect.addEventListener('change', setupRefreshTimer);
    </script>
</body>
</html>